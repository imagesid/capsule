/* **********************************************************
 * Copyright (c) 2008-2010 VMware, Inc. All Rights Reserved.
 * **********************************************************/

/*
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * ioblazer.c --
 *
 *      Version: 1.01
 *
 *      A multi-platform storage stack micro-benchmark.  The workload
 *      generated by IOBlazer is highly customizable as parameters like
 *      IO size and pattern, number of outstanding IOs, inter-IO gap,
 *      read vs. write mix, buffering vs. direct IO, etc., can be
 *      configured independently.  The performance metrics reported are
 *      throughput (in terms of IOPS and bytes/s) and IO latency.
 *
 *      For documentation and change log please see the README file.
 *
 */

// #include "../include/libCacheSim/cache.h"
// #include "../include/libCacheSim/reader.h"

#ifndef __LINUX
#define __LINUX__
#endif
#ifndef _LARGEFILE64_SOURCE
#define _LARGEFILE64_SOURCE
#endif

#if defined(__OSX__) || defined(__LINUX__)
#define __UNIX__
#endif

#ifdef __UNIX__
#define DWORD unsigned long
#define DWORD64 unsigned long long
#define BOOL int
#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE 0
#endif

#define SYSTEMTIME struct timeval
#define HANDLE pthread_t
#define __inline inline
#undef _WIN32
#endif

#ifdef _WIN32
#undef __UNIX__
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <signal.h>
#ifdef _WIN32
#include <Windows.h>
#include <WinDef.h>
#include <process.h>
#include "getopt.h"
#else
#ifdef __UNIX__
#define __USE_GNU
#include <pthread.h>
#include <errno.h>
#include <unistd.h>
#include <fcntl.h>
#include <ctype.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/stat.h>
#ifdef __LINUX__
#include <libaio.h>
#endif
#ifdef __OSX__
#include <aio.h>
#endif
#else
#error Unsupported OS
#endif  // __UNIX__
#endif  // _WIN32

#ifndef O_LARGEFILE
#define O_LARGEFILE 0
#endif

#ifndef O_DIRECT
#define O_DIRECT 0
#endif

#define LBA_THRESHOLD 100000000ULL
#define BILLION_THRESHOLD 1000000000ULL
#define BILLION_L 3000


/*
 * Constants and macros
 */
#if defined(__DEBUG__) || defined(_DEBUG)
#define DEBUG_MSG(...) fprintf(stderr, __VA_ARGS__)
#else
#define DEBUG_MSG(...) do { } while (0)
#endif
#define ROUNDDOWN(x,y)      ((x) / (y) * (y))

#define STR_SIZE                                1000
#define FILE_NAME                      "ioblazer.db"
#define DISK_SECTOR_SIZE                        4096     //  512 B
#define DISK_IO_ALIGNMENT           DISK_SECTOR_SIZE
#define MEM_PAGE_SIZE                           4096     //    4 KB
#define DB_PAGE_SIZE                            8192     //    8 KB
#define MAX_RD_SIZE             (128 * DB_PAGE_SIZE)     //    1 MB
#define MAX_WR_SIZE             ( 16 * DB_PAGE_SIZE)     //  128 KB
#ifdef __OSX__
#define MAX_OUTSTANDING_IOS                       16
#else
#define MAX_OUTSTANDING_IOS                      256
#endif


/*
 * Dfault parameter values
 */ 
#define DB_FILE_PAGES                            128     // 1 MB
#define MEM_BUFFER_PAGES                         256     // 1 MB
#ifdef __OSX__
#define OUTSTANDING_IOS                           16
#else
#define OUTSTANDING_IOS                           32
#endif
#define LATENCY_THRESHOLD                       5000     // 5 seconds
#define TEST_DURATION                            180     // 3 minutes
#define NUM_THREADS                                1
#define BIMOD_LARGEIO_PROB                         0.01
#define RD_RATIO                                   1.0
#define IO_GAP                                     0
#define IO_ACCESS_PATTERN                        'r'
#define IO_SIZE_PATTERN                          'f'
#define OUTSTANDING_IOS_PATTERN                  'f'
#define IO_GAP_PATTERN                           'f'
#define OUTPUT_FORMAT                            'f'
#define IO_SIZE                         DB_PAGE_SIZE
#define BUFFER_SIZE                (MEM_BUFFER_PAGES * MEM_PAGE_SIZE)
#define FILE_SIZE                     (DB_FILE_PAGES * DB_PAGE_SIZE)
#ifdef _WIN32
#define FILE_PATH                          "d:\\tmp"
#define DEVICE_PATH          "\\\\.\\PhysicalDrive1"
#define DEVICE_PREFIX                            17
#endif
#ifdef __LINUX__
#define FILE_PATH                        "/mnt/new_root"
#define DEVICE_PATH                       "/dev/sdb"
#endif
#ifdef __OSX__
#define FILE_PATH                   "/Volumes/disk0"
#define DEVICE_PATH                     "/dev/disk1"
#endif


/*
 * Types
 */
typedef enum {
  OP_RD = 0,
  OP_WR
} IOOP;

#ifdef __UNIX__
#ifdef __LINUX__
   typedef struct iocb iocb_t;
   typedef struct iocb *iocbPtr_t;
#endif
#ifdef __OSX__
   typedef struct aiocb iocb_t;
   typedef struct aiocb *iocbPtr_t;
   typedef int io_context_t;  
#endif
#endif

#include "../libCacheSim/include/libCacheSim/cache.h"
#include "../libCacheSim/include/libCacheSim/reader.h"

/* Outstanding IO state */
typedef struct {
   DWORD   dwStartTime;
   DWORD64 qwOffset;
   DWORD   dwSize;
   IOOP    op;
   request_t *req; 
   BOOL in_cache;
#ifdef _WIN32
   OVERLAPPED ol;
   FILE_SEGMENT_ELEMENT *aSegArray;
#endif
#ifdef __UNIX__
   iocb_t iocb;
#endif
} OUTSTANDING_IO;


/* Thread state */
typedef struct {
   DWORD   dwThreadID;
   DWORD64 qwTotalBytesTransferred;
   DWORD   dwCompletedIOs;
   DWORD   dwIosAboveLatThresh;
   double  dAvgLatency;
   DWORD   dwMaxLatency;
   DWORD64 qwLastOffset;
   HANDLE  hThread;
   BOOL    *pTestFinished;
   reader_t *reader;
   cache_t *cache;
#ifdef _WIN32
   HANDLE  *phMainToWorkerEvents;
   HANDLE  *phWorkerToMainEvents;
#endif
#ifdef __UNIX__
   pthread_cond_t  *pCond;
   pthread_mutex_t *pMutex;
   int             *pSynchedThreads;
#endif
} THREAD_STATE;

/* Shared information between main and threads */
typedef struct {
      char *pszBuf;              // Shared buffer
      THREAD_STATE *sThreads;
      BOOL bTestFinished;
#ifdef _WIN32
      HANDLE *hMainToWorkerEvents, *hWorkerToMainEvents;
#endif
#ifdef __UNIX__
      pthread_cond_t cond;
      pthread_mutex_t mutex;
      int synchedThreads;
#endif
} THREAD_INFO;



/* Information shared between main and threads */
THREAD_INFO threadInfo;

/* Options and Parameters */
typedef struct {
   DWORD   dwNumThreads;
   DWORD   dwTestDuration;
   double  dRDRatio;
   DWORD64 qwFileSize;
   DWORD   dwBufferSize;
   DWORD   dwIOSize;
   DWORD   dwOutstandingIOs;
   DWORD   dwIOGap;
   DWORD   dwIOAlignment;
   DWORD   dwLatencyThreshold;
   char    cIoAccessPattern;
   char    cIoSizePattern;
   char    cOutstandingIOsPattern;
   char    cIOGapPattern;
   char    cOutputFormat;
   char    lpDevFilePath[STR_SIZE];
   BOOL    bDataChecksum;
   BOOL    bFillFile;
   BOOL    bBufferedIO;
   BOOL    bRawDev;
   BOOL    bTrace;
   char    lpTraceFile[STR_SIZE];
} OPTIONS;


/* 
 * Globals
 */

/* Options */
static OPTIONS opt = {
   NUM_THREADS,             // dwNumThreads
   TEST_DURATION,           // dwTestDuration
   RD_RATIO,                // dRDRatio
   FILE_SIZE,               // qwFileSize
   BUFFER_SIZE,             // dwBufferSize
   IO_SIZE,                 // dwIOSize
   OUTSTANDING_IOS,         // dwOutstandingIOs
   IO_GAP,                  // dwIOGap
   DISK_IO_ALIGNMENT,       // dwIOAlignment
   LATENCY_THRESHOLD,       // dwLatencyThreshold
   IO_ACCESS_PATTERN,       // cIoAccessPattern
   IO_SIZE_PATTERN,         // cIoSizePattern
   OUTSTANDING_IOS_PATTERN, // cOutstandingIOsPattern
   IO_GAP_PATTERN,          // cIOGapPattern
   OUTPUT_FORMAT,           // cOutputFormat
   FILE_PATH,               // lpDevFilePath
   FALSE,                   // bDataChecksum
   FALSE,                   // bFillFile
   FALSE,                   // bBufferedIO
   FALSE,                   // bRawDev
   FALSE,                   // bTrace
   ""                       // bTraceFile
};



/*
 * Local functions
 */
static void usage(void);
static double urand(void);
static DWORD getUniRndIOSize(DWORD dwIOSize);
static DWORD getBiModRndIOSize(int op);
static DWORD64 getIOOffset(DWORD64 offset);
static DWORD getRndBufPageAddr(void);
static IOOP getIOOp(void);
static DWORD getIOSize(IOOP op, DWORD64 qwOffset);
static DWORD convSysTimeToMillisec(SYSTEMTIME *sysTime);
static void uSleep(DWORD dwTime);
#ifdef __OSX__
static void io_prep_pread(iocbPtr_t iocb, int fd, char *memOffset, size_t sz,
                          off_t pos);
static void io_prep_pwrite(iocbPtr_t iocb, int fd, char *memOffset, size_t sz,
                           off_t pos);
static int io_submit(io_context_t ctx, long nr, iocbPtr_t iocbp[]);
#endif
#ifdef _WIN32
static unsigned __stdcall workerThread(LPVOID lpParam);
#endif
#ifdef __UNIX__
static void *workerThread(void *lpParam);
#endif

// static void
// CtrlCHandler(int signal);

// static void
// createWorkerThreads(reader_t *reader, cache_t *cache);

// void
// synchWorkerThreads(void);

// static void
// GetSystemTime(SYSTEMTIME *t);

// static void
// Sleep(DWORD dwTime);


/*
 *-----------------------------------------------------------------------------
 *
 * usage --
 *
 *      Prints out usage info
 *
 * Results:
 *      None
 *
 * Side effects:
 *      None
 *
 *-----------------------------------------------------------------------------
 */

static void
usage(void)
{
   printf("\nusage: ioblazer [options]\n");
   printf("\n\tOptions      Description                                  "
          "Default\n\n");
   printf("\t-a <s|r>     IO access pattern: sequential or random      %c\n",
          IO_ACCESS_PATTERN);
   printf("\t-A <align>   Disk IO alignment (multiple of 512 B)        %d B\n",
          DISK_IO_ALIGNMENT);
   printf("\t-b <size>    Memory buffer size in MB                     %d MB\n",
          MEM_BUFFER_PAGES * MEM_PAGE_SIZE / 1024 / 1024);
   printf("\t-B           Buffered IOs (go thru FS buffer cache)       %d\n",
          FALSE);
   printf("\t-c           Computes pseudo-checksum on data             %d\n",
          FALSE);
   printf("\t-d <path>    Device or File path                          %s\n",
          FILE_PATH);
   printf("\t-f <size>    File  or Device size in MB                   %d MB\n",
         DB_FILE_PAGES * DB_PAGE_SIZE / 1024 / 1024);
   printf("\t-F           Fill the test file before starting IOs       %d\n",
          FALSE);
   printf("\t-g <gap>     Inter-burst time in microseconds (Avg)       %d us\n",
          IO_GAP);
   printf("\t-G <f|u>     Inter-burst time pattern (fixed or uniform)  %c\n",
          IO_GAP_PATTERN);
   printf("\t-h           Print this message\n");
   printf("\t-i <size>    IO size in B (Avg)                           %d B\n",
          DB_PAGE_SIZE);
   printf("\t-I <f|u|b>   IO size pattern (fixed, uniform or bimodal)  %c\n",
          IO_SIZE_PATTERN);
   printf("\t-l <thresh>  Latency Alarm Threshold in ms                %d ms\n",
          LATENCY_THRESHOLD);
   printf("\t-o <#OIOs>   Burst size [aka Outstanding IOs] (Avg)       %d\n",
          OUTSTANDING_IOS);
   printf("\t-O <f|u>     Burst size (fixed or uniform)                %c\n",
          OUTSTANDING_IOS_PATTERN);
   printf("\t-p <c|f|z>   Printout format: csv, free, csv no header    %c\n",
          OUTPUT_FORMAT);
   printf("\t-P <file>    Playback VSCSI trace from 'file'             NULL\n");
   printf("\t-r <ratio>   Read ratio (1.0 = 100%% read)                 %3.1f\n",
          RD_RATIO);
   printf("\t-R           Raw Device Access                            %d\n",
          FALSE);
   printf("\t-t <time>    Test duration in s                           %d s\n",
          TEST_DURATION);
   printf("\t-w <num>     Number of worker threads                     %d\n",
          NUM_THREADS);
   printf("\n");
}


/*
 *-----------------------------------------------------------------------------
 *
 * urand --
 *
 *      Generate a double precision random number uniformly distributed
 *      in [0, 1) interval
 *
 * Results:
 *      A uniformly distributed random number
 *
 * Side effects:
 *      None
 *
 *-----------------------------------------------------------------------------
 */
static __inline double
urand(void)
{
   return ((double)rand()) / ((double)RAND_MAX + 1) ;
}


/*-----------------------------------------------------------------------------
 *
 * getRndBufPageAddr --
 *
 *     Generates a random buffer page number uniformly distributed in
 *     the [0, opt.dwBufSize] interval in MEM_PAGE_SIZE increments.
 *
 * Results:
 *      A uniformly random page number
 *
 * Side effects:
 *      None
 *
 *-----------------------------------------------------------------------------
 */
static __inline DWORD
getRndBufPageAddr(void)
{
   return ROUNDDOWN((DWORD)(urand() * opt.dwBufferSize), MEM_PAGE_SIZE);
}


/*
 *-----------------------------------------------------------------------------
 *
 * getUniRndIOSize --
 *
 *     Generates a random size for the next IO uniformly distributed in
 *     the interval [0, 2 * dwIOSize] interval.  The average size is
 *     obviously dwIOSize
 *
 * Results:
 *      A uniformly distributed random IO size
 *
 * Side effects:
 *      None
 *
 *-----------------------------------------------------------------------------
 */
static __inline DWORD
getUniRndIOSize(DWORD dwIOSize)
{
   return (DWORD)(urand() * 2 * dwIOSize);
}


/*
 *-----------------------------------------------------------------------------
 *
 * getBiModRndIOSize --
 *
 *     Generates a random size for the next IO distributed in a bimodal
 *     fashion as determined by the BIMOD_LARGEIO_PROB probability.
 *     Large IOs are MAX_WR_SIZE for writes and MAX_RD_SIZE for reads.
 *     Small IOs are 1 DB_PAGE_SIZE regardless.
 *
 * Results:
 *      A random IO size distributed in a bimodal fashion
 *
 * Side effects:
 *      None
 *
 *-----------------------------------------------------------------------------
 */
static __inline DWORD
getBiModRndIOSize(int op)
{
   int sz;

   if (urand() < BIMOD_LARGEIO_PROB) {
      if (op == OP_RD) {
         sz = MAX_RD_SIZE;
      } else {
         sz = MAX_WR_SIZE;
      }
   } else {
      sz = DB_PAGE_SIZE;
   }

   return sz;
}


/*-----------------------------------------------------------------------------
 *
 * getIOSize --
 *
 *     Generates an IO size wich may be fixed, uniformly distributed or
 *     distributed accroding to a bi-modal random distribution.  The IO size
 *     is trimmed if the resulting IO exceeds the file/device size and rounded
 *     down to the nearest multiple of the sector size.
 *
 * Results:
 *      An IO size
 *
 * Side effects:
 *      None
 *
 *-----------------------------------------------------------------------------
 */
static DWORD
getIOSize(IOOP op, DWORD64 qwOffset)
{
   DWORD dwSize;

   switch (opt.cIoSizePattern) {
   case 'f':  // Fixed
      dwSize = opt.dwIOSize;
      break;
   case 'u':  // Uniform
      dwSize = getUniRndIOSize(opt.dwIOSize);
      break;
   case 'b':  // Bimodal
      dwSize = getBiModRndIOSize(op);
   break;
      default:
   fprintf(stderr, "Illegal IO Size pattern\n");
      exit(-1);
   }

   /* Trim size if IO ends past EOF */
   if (qwOffset + dwSize > opt.qwFileSize) {
      dwSize = (DWORD) (opt.qwFileSize - qwOffset);
   }

   dwSize = ROUNDDOWN(dwSize, DISK_SECTOR_SIZE);
   if (dwSize < DISK_SECTOR_SIZE) {
      dwSize = DISK_SECTOR_SIZE;
   }
   dwSize = 1;
   return dwSize;
}


/*-----------------------------------------------------------------------------
 *
 * getIOOffset --
 *
 *     Generates an offset within the db file in DISK_SECTOR_SIZE increments
 *     depending on the access pattern:
 *       - sequential: next offset
 *       - random    : random offset uniformly distributed in [0, qwFileSize]
 *
 * Results:
 *      An offset in the DB file
 *
 * Side effects:
 *      None
 *
 *-----------------------------------------------------------------------------
 */
static __inline DWORD64
getIOOffset(DWORD64 qwLastOffset)
{
   DWORD64 qwOffset;

   if (opt.cIoAccessPattern == 'r' ) {
      qwOffset = (DWORD64)(urand() * opt.qwFileSize);
   } else {
      qwOffset = qwLastOffset + opt.dwIOSize;
      if (qwOffset > opt.qwFileSize) {
         qwOffset = 0;
      }
   }
//   return ROUNDDOWN(qwOffset, DISK_SECTOR_SIZE);
   return ROUNDDOWN(qwOffset, opt.dwIOAlignment);
}


/*-----------------------------------------------------------------------------
 *
 * getIOOp --
 *
 *     Generates a random IO operation (RD or WR) with a probablity
 *     determined by the RDRatio parameter.
 *
 * Results:
 *      A  random IO operation
 *
 * Side effects:
 *      None
 *
 *-----------------------------------------------------------------------------
 */
static __inline IOOP
getIOOp(void)
{
   return urand() < opt.dRDRatio ? OP_RD : OP_WR;
}


/*-----------------------------------------------------------------------------
 *
 * getOutstandingIOs --
 *
 *     Generates a burst size (number of outstanding IOs) which may 
 *     be fixed or uniformly distributed.
 *
 * Results:
 *      An burst size
 *
 * Side effects:
 *      None
 *
 *-----------------------------------------------------------------------------
 */
static DWORD
getOutstandingIOs()
{
   DWORD dwOutstandingIOs;

   switch (opt.cOutstandingIOsPattern) {
   case 'f':  // Fixed
      dwOutstandingIOs = opt.dwOutstandingIOs;
      break;
   case 'u':  // Uniform
      dwOutstandingIOs = (DWORD)(urand() * 2 * opt.dwOutstandingIOs);
      dwOutstandingIOs++;
      break;
   default:
      fprintf(stderr, "Illegal Outstanding IOs pattern\n");
      exit(-1);
   }

   if (dwOutstandingIOs > MAX_OUTSTANDING_IOS) {
      dwOutstandingIOs = MAX_OUTSTANDING_IOS;
   }

   return dwOutstandingIOs;
}


/*-----------------------------------------------------------------------------
 *
 * getIOGap --
 *
 *     Generates a inter-burst gap (time in us between two bursts)
 *     which may be fixed or uniformly distributed.
 *
 * Results:
 *      An inter-burst gap
 *
 * Side effects:
 *      None
 *
 *-----------------------------------------------------------------------------
 */
static DWORD
getIOGap()
{
   DWORD dwIOGap;

   switch (opt.cIOGapPattern) {
   case 'f':  // Fixed
      dwIOGap = opt.dwIOGap;
      break;
   case 'u':  // Uniform
      dwIOGap = (DWORD)(urand() * 2 * opt.dwIOGap);
      break;
   default:
      fprintf(stderr, "Illegal inter-burst-gap pattern\n");
      exit(-1);
   }

   return dwIOGap;
}


/*-----------------------------------------------------------------------------
 *
 * getNextIO --
 *
 *     Generates a new IO either by reading its specification from the 
 *     trace file, if trace mode is enabled, or based on the config options.
 *
 * Results:
 *      IO type (R/W), offset and size
 *
 * Side effects:
 *      If in trace mode:
 *      - The trace file is opened at the first call
 *      - The trace file pointer is advanced to the next line at every call
 *
 *-----------------------------------------------------------------------------
 */
static BOOL
getNextIO(OUTSTANDING_IO *lpOIO, DWORD64 qwLastOffset, reader_t *reader) {

   /*
    * If trace mode is enabled, get the next IO from the trace file,
    * otherwise generate a new IO based on the IO spec.
    */
   if (opt.bTrace) {
      static FILE    *fp = NULL;
      static DWORD64 qwPrevTimestamp = 0;
      static DWORD   dwIONum = 0;
      DWORD          dwIOGap;
      DWORD          dwSG;
      DWORD64        qwTimestamp, qwSerial;
      char           lpOper[20];
      char           lpBuf[STR_SIZE];
      BOOL           bValidIO = FALSE;

      /*
       * Open the trace file if not open already
       */
      if (fp == NULL) {
         fp = fopen(opt.lpTraceFile, "r");
         if (!fp) {
            printf("Cannot open trace file file %s\n", opt.lpTraceFile);
            exit(-1);
         }
      }

      /*
       * Parse the next line from the trace file and extract IO specs
       */
      while (fgets(lpBuf, STR_SIZE, fp)) {
         if (sscanf(lpBuf, "%llu,%lu,%lu,%[^,],%llu,%llu", &qwSerial,
                    &lpOIO->dwSize, &dwSG, lpOper, &lpOIO->qwOffset,
                    &qwTimestamp) == 6) {
            printf("lpBuf %s\n", lpBuf);
            
            if (strcmp(lpOper, "read") == 0) {
               lpOIO->op = OP_RD;
               bValidIO = TRUE;
               break;
            } else if (strcmp(lpOper, "write") == 0){
               lpOIO->op = OP_WR;
               bValidIO = TRUE;
               break;
            }
         }
      }

      if (bValidIO) {
         dwIONum++;
         if (qwPrevTimestamp == 0) {
            qwPrevTimestamp = qwTimestamp;
         }
         dwIOGap = (DWORD)(qwTimestamp - qwPrevTimestamp);
         qwPrevTimestamp = qwTimestamp;

         DEBUG_MSG("IO#%lu: gap=%lu  op=%s  lba=%llu  size=%lu\n",
                   dwIONum, dwIOGap, lpOper, lpOIO->qwOffset,
                   lpOIO->dwSize);

         if (dwIONum % 100 == 0) {
            fprintf(stderr, "Playing back IO#%7lu\r", dwIONum);
         }

         lpOIO->qwOffset *= DISK_SECTOR_SIZE;

         /* Wait the prescribed time before submitting the IO */
         if (dwIOGap > 0) {
           uSleep(dwIOGap);
         }
      } else {
         /* End of trace file, forced exit out of the Issue Loop */
         return FALSE;
      }
   } else {
      // lpOIO->op = getIOOp();
      // lpOIO->qwOffset = getIOOffset(qwLastOffset);
      // lpOIO->dwSize = getIOSize(lpOIO->op, lpOIO->qwOffset);


      request_t *req = new_request();
 
      read_one_req(reader, req);
      if(req->valid){
         // printf("reqid %d\n", req->obj_id);
         lpOIO->req = req; 
         lpOIO->op = getIOOp();
         lpOIO->qwOffset = getIOOffset(qwLastOffset);
         lpOIO->dwSize = getIOSize(lpOIO->op, lpOIO->qwOffset);
         //lpOIO->dwSize = 1;// 1byte
   
         // printf("op=%d  lba=%llu  size=%lu\n",
         //             lpOIO->op, lpOIO->qwOffset,
         //             lpOIO->dwSize);
         DEBUG_MSG("op=%d  lba=%llu  size=%lu\n",
                     lpOIO->op, lpOIO->qwOffset,
                     lpOIO->dwSize); 
      } else {
         /* End of trace file, forced exit out of the Issue Loop */
         return FALSE;
      }
   }

   return TRUE;
}

static BOOL
getNextIOx(OUTSTANDING_IO *lpOIO, DWORD64 qwLastOffset, reader_t *reader) {
   lpOIO->op = getIOOp();
   lpOIO->qwOffset = getIOOffset(qwLastOffset);
   lpOIO->dwSize = getIOSize(lpOIO->op, lpOIO->qwOffset);
   return TRUE;
}


/*-----------------------------------------------------------------------------
 *
 * computePseudoChecksum --
 *
 *     Computes a 32-bit checksum of a dwSize bytes long block of data pointed
 *     to by pszBuf.  'Pseudo' refers to the fact that the checksum is not
 *     computed for correctness purposes but to force the data read/written to
 *     the disk to go through the processor cache.  This is done to simulate the
 *     data creation/consumption by the application.
 *
 * Results:
 *      A 32-bit checksum.
 *
 * Side effects:
 *      Forcing data through the processor cache.
 *
 *-----------------------------------------------------------------------------
 */
static DWORD
computePseudoChecksum(char *pszBuf, DWORD dwSize)
{   
   DWORD dwChecksum = 0;
   unsigned k;

    for (k = 0; k < dwSize; k++) {
       dwChecksum += pszBuf[k];
    }
    return dwChecksum;
}


/*-----------------------------------------------------------------------------
 *
 * convSysTimeToMillisec --
 *
 *     Converts a SYSTEMTIME value in milliseconds.
 *
 * Results:
 *      A time in milliseconds
 *
 * Side effects:
 *      None
 *
 *-----------------------------------------------------------------------------
 */
static DWORD
convSysTimeToMillisec(SYSTEMTIME *sysTime)
{
   DWORD millisec;

#ifdef _WIN32
   millisec = sysTime->wDay * 24 * 60 * 60 * 1000 +
                 sysTime->wHour  * 60 * 60 * 1000 +
                 sysTime->wMinute     * 60 * 1000 +
                 sysTime->wSecond          * 1000 +
                 sysTime->wMilliseconds;
#endif
#ifdef __UNIX__
   millisec = sysTime->tv_sec * 1000 + sysTime->tv_usec / 1000;
#endif
   return millisec;
}


/*-----------------------------------------------------------------------------
 *
 * convSysTimeToMicrosec --
 *
 *     Converts a SYSTEMTIME value in microseconds.
 *
 * Results:
 *      A time in microsecondseconds
 *
 * Side effects:
 *      None
 *
 *-----------------------------------------------------------------------------
 */
static DWORD
convSysTimeToMicrosec(SYSTEMTIME *sysTime)
{
   DWORD microsec;

#ifdef _WIN32
   microsec = convSysTimeToMillisec(sysTime) * 1000;
#endif
#ifdef __UNIX__
   microsec = sysTime->tv_sec * 1000000 + sysTime->tv_usec;
#endif
   return microsec;
}


/*-----------------------------------------------------------------------------
 *
 * uSleep --
 *
 *     Sleep for the specified number fo microseconds
 *
 * Results:
 *      None
 *
 * Side effects:
 *      None
 *
 *-----------------------------------------------------------------------------
 */
static void
uSleep(DWORD dwTime)
{
#ifdef _WIN32
   Sleep(dwTime / 1000);
#endif
#ifdef __UNIX__
   struct timespec t, r;

   dwTime *= 1000;
   t.tv_sec = dwTime / 1000000000;
   t.tv_nsec = dwTime % 1000000000;
   nanosleep(&t, &r);
#endif
}


/*
 * UNIX  helper functions
 */
#ifdef __UNIX__
static void
Sleep(DWORD dwTime)
{
   uSleep(dwTime * 1000);
}

static void
GetSystemTime(SYSTEMTIME *t) {
   gettimeofday(t, NULL);
}
#endif


#ifdef __OSX__
/*
 * OSX helper functions
 */
void
io_prep_pread(iocbPtr_t iocb, int fd, char *memOffset, size_t sz, off_t pos)
{
      iocb->aio_fildes = fd;
      iocb->aio_lio_opcode = LIO_READ;
      iocb->aio_buf = memOffset;
      iocb->aio_nbytes = sz;
      iocb->aio_offset = pos;
}

void
io_prep_pwrite(iocbPtr_t iocb, int fd, char *memOffset, size_t sz, off_t pos)
{
      iocb->aio_fildes=fd;
      iocb->aio_buf = memOffset;
      iocb->aio_lio_opcode = LIO_WRITE;
      iocb->aio_nbytes = sz;
      iocb->aio_offset = pos;
}

static int
io_submit(io_context_t ctx, long nr, iocbPtr_t iocbp[])
{
   return lio_listio(LIO_NOWAIT, iocbp, nr, NULL);
}
#endif


/*-----------------------------------------------------------------------------
 *
 * workerThread --
 *
 *     The poor worker thread.
 *
 * Results:
 *      None
 *
 * Side effects:
 *      Quite a lot!
 *
 *-----------------------------------------------------------------------------
 */
#ifdef _WIN32
static unsigned __stdcall
workerThread(LPVOID lpParam)
{
   THREAD_STATE   *lpThreadState = (THREAD_STATE *) lpParam;
   DWORD          dwThreadId = lpThreadState->dwThreadID;
   OUTSTANDING_IO outIO[MAX_OUTSTANDING_IOS];
   DWORD dwBytesTransferred;

   unsigned       i, err;
   char           lpFileName[STR_SIZE];
   HANDLE         hFile, hCompPort;
   ULONG_PTR      CompKey = 0x1234;
   OVERLAPPED     Overlapped;
   DWORD          dwCreationDisposition;
   DWORD          dwFlagsAndAttributes;

   DEBUG_MSG("Thread #%lu: initializing...\n", lpThreadState->dwThreadID);

   memset(outIO, 0, MAX_OUTSTANDING_IOS * sizeof(OUTSTANDING_IO));

   /*
    * Open device or test file
    */
   if (opt.bRawDev) {
      int devNum = atoi(opt.lpDevFilePath + DEVICE_PREFIX);
      char devName[STR_SIZE];

      if (devNum < 1) {
         fprintf(stderr, "Error: RAW disk access forbidden on"
                         "\\\\.\\PhysicalDrive0\n");
         exit(-1);
      }
      strncpy(devName, opt.lpDevFilePath, DEVICE_PREFIX);
      devName[DEVICE_PREFIX] = '\0';
      sprintf_s(lpFileName, STR_SIZE, "%s%d", devName, devNum +
                lpThreadState->dwThreadID);
      dwCreationDisposition = OPEN_EXISTING;
   } else {
      sprintf_s(lpFileName, STR_SIZE, "%c%s\\%s", opt.lpDevFilePath[0] +
                (char)lpThreadState->dwThreadID, &opt.lpDevFilePath[1],
                FILE_NAME);
      dwCreationDisposition = OPEN_ALWAYS;
   }

   if (opt.bBufferedIO) {
      dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED;
   } else {
      dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | 
                             FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING;
   }

   hFile = CreateFile(lpFileName,
                      GENERIC_READ | GENERIC_WRITE,
                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                      NULL,
                      dwCreationDisposition,
                      dwFlagsAndAttributes,
                      NULL);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, "\nERROR: Cannot open '%s' file. Last error = %d\n",
              lpFileName, GetLastError());
      exit(-1);
   }

   
   /*
    * Fill the test file
    */
   if (opt.bFillFile && !opt.bRawDev) {
      memset(&Overlapped, 0, sizeof(OVERLAPPED));
      for (i = 0; i < opt.qwFileSize / (MAX_WR_SIZE); i++ ) {
         DWORD64 offset = (DWORD64)i * MAX_WR_SIZE;

         Overlapped.OffsetHigh = offset >> 32;
         Overlapped.Offset = offset & 0xffffffff;
         
         if (!WriteFile(hFile,
                        threadInfo.pszBuf,
                        MAX_WR_SIZE,
                        NULL,
                        &Overlapped)) {
            if ((err = GetLastError()) != ERROR_IO_PENDING) {
               fprintf(stderr, "\nERROR: Cannot create '%s' file.  "
                               "Last error = %d\n", lpFileName, err);
               exit(-1);
            }
         }
         GetOverlappedResult(hFile,
                             &Overlapped,
                             &dwBytesTransferred,
                             TRUE);
         if (dwBytesTransferred != MAX_WR_SIZE) {
            fprintf(stderr, "\nERROR: Cannot create '%s' file. "
                    "Last write was incomplete", lpFileName);
            exit(-1);
         }
      }
   }

   /*
    * Create the completion port used to get IO completion notifications
    */
   hCompPort = CreateIoCompletionPort(hFile, NULL, CompKey, 0);
   if (hCompPort == NULL) {
      fprintf(stderr, "\nERROR: Cannot create completion port\n");
      exit(-1);
   }

   /* Signal main that the worker is ready */
   SetEvent(lpThreadState->phWorkerToMainEvents[lpThreadState->dwThreadID]);

   /* Wait for start signal from main */
   WaitForSingleObject(lpThreadState->phMainToWorkerEvents[lpThreadState->dwThreadID], INFINITE);

   DEBUG_MSG("Thread #%lu: starting IOs on '%s'\n",
             lpThreadState->dwThreadID, lpFileName);

   /*
    * Main test loop
    */
    while (!*(lpThreadState->pTestFinished)) {
      DWORD dwOutstandingIOs;
      DWORD dwCurrOutstandingIOs;
      DWORD dwBurstStartTime, dwBurstFinishTime;
      SYSTEMTIME sNow;
      DWORD dwChecksum;
      int iIOGap;
      OUTSTANDING_IO *lpOIO;
      unsigned res, err;

      /*
       * IO Issue loop
       */
      dwOutstandingIOs = getOutstandingIOs();
      dwCurrOutstandingIOs = 0;
      while (dwCurrOutstandingIOs < dwOutstandingIOs) {
         DWORD dwNumMemPages;
         unsigned j;

         /*
          * Prepare a new I/O
          */
         lpOIO = &outIO[dwCurrOutstandingIOs];
         if (!getNextIO(lpOIO, lpThreadState->qwLastOffset)) {
            *(lpThreadState->pTestFinished) = TRUE;
            break;
         }
         lpThreadState->qwLastOffset = lpOIO->qwOffset;

         /*
          * Create scatter/gather array picking random pages from
          * the memory buffer
          */
         dwNumMemPages = lpOIO->dwSize / MEM_PAGE_SIZE + 
                         (lpOIO->dwSize % MEM_PAGE_SIZE > 0);
         lpOIO->aSegArray = calloc((dwNumMemPages + 1),
                                   sizeof(FILE_SEGMENT_ELEMENT));
         if (lpOIO->aSegArray == NULL) {
            fprintf(stderr, "Could not allocate memory for Segment "
                            " Array\n");
            exit(-1);
         }
         for (j = 0; j < dwNumMemPages; j++) {
            lpOIO->aSegArray[j].Buffer = threadInfo.pszBuf + getRndBufPageAddr();

            /*
             * If the checksum option is enabled,
             * compute it before issuing the write
             */
            if (lpOIO->op == OP_WR && opt.bDataChecksum == TRUE) {
               dwChecksum = computePseudoChecksum(
                                  (char *)lpOIO->aSegArray[j].Buffer,
                                  MEM_PAGE_SIZE);
            }
         }
         lpOIO->aSegArray[j].Buffer = NULL;
         lpOIO->ol.Offset = lpOIO->qwOffset & 0xffffffff;
         lpOIO->ol.OffsetHigh = lpOIO->qwOffset >> 32;

         /*
          * Issue the IO operation
          */
         GetSystemTime(&sNow);
         lpOIO->dwStartTime = convSysTimeToMicrosec(&sNow);
         if (dwCurrOutstandingIOs == 0) {
            dwBurstStartTime = lpOIO->dwStartTime;
         }


         DEBUG_MSG("%lu %s %3lu issuing  : offset=%Lu size=%lu %lu\n",
                   lpOIO->dwStartTime,
                   (lpOIO->op == OP_RD ? "Read" : "Write"),
                   dwCurrOutstandingIOs, lpOIO->qwOffset, lpOIO->dwSize);

         if (lpOIO->op == OP_RD) {
            if (opt.bBufferedIO) {
               res = ReadFile(hFile,
                              threadInfo.pszBuf,
                              lpOIO->dwSize,
                              NULL,
                              &lpOIO->ol);
            } else {
               res = ReadFileScatter(hFile,
                                     lpOIO->aSegArray,
                                     lpOIO->dwSize, NULL,
                                     &lpOIO->ol);
            }
         } else {
            if (opt.bBufferedIO) {
               res = WriteFile(hFile,
                               threadInfo.pszBuf,
                               lpOIO->dwSize,
                               NULL,
                               &lpOIO->ol);
            } else {
               res = WriteFileGather(hFile,
                                     lpOIO->aSegArray,
                                     lpOIO->dwSize, NULL,
                                     &lpOIO->ol);
            }
         }
         if (res == 0) {
            err = GetLastError();
            if (err != ERROR_IO_PENDING) {
               fprintf(stderr, "Last IO operation failed: Error=%u\n", err);
               if (err == ERROR_HANDLE_EOF && lpOIO->op == OP_RD) {
                  fprintf(stderr, "EOF on READ. Please check file size.");
               }
               exit(-1);
            }
         }

         dwCurrOutstandingIOs++;

      }  // while (dwCurrOutstandingIOs < dwOutstandingIOs)

      /*
       * IO completion loop
       */
      while (dwCurrOutstandingIOs > 0) {
         DWORD dwLatency;
         LPOVERLAPPED lpOverlapped;

         /*
          * IO completion
          */
         if (!GetQueuedCompletionStatus(hCompPort, &dwBytesTransferred,
                                        &CompKey, &lpOverlapped, INFINITE)) {
            fprintf(stderr, "ERROR: GetQueuedCompletionStatus failed\n");
            if (lpOverlapped != NULL) {
               err = GetLastError();
               fprintf(stderr, "Last Error = %d\n", err);
               exit(-1);
            }
         }

         for (i = 0; i < dwOutstandingIOs; i++) {
            lpOIO = &outIO[i];
            if (&lpOIO->ol == lpOverlapped) {
               unsigned j;

               /*
                * IO completed successfully: update counters, compute
                * latency and warn if it exceeds the alarm threshold
                */
               GetSystemTime(&sNow);
               lpThreadState->dwCompletedIOs++;
               lpThreadState->qwTotalBytesTransferred += lpOIO->dwSize;
               dwLatency = convSysTimeToMicrosec(&sNow) - lpOIO->dwStartTime;
               lpThreadState->dAvgLatency += dwLatency;
               if (dwCurrOutstandingIOs == 1) {
                  dwBurstFinishTime = convSysTimeToMicrosec(&sNow);
               }
               if (dwLatency / 1000 > opt.dwLatencyThreshold){
                  lpThreadState->dwIosAboveLatThresh++;
                  fprintf(stderr, "WARNING: IO #%lu took longer than %lu ms to "
                          "complete (%lu ms)\n", lpThreadState->dwCompletedIOs,
                           opt.dwLatencyThreshold, dwLatency / 1000);
               }
               if (lpThreadState->dwMaxLatency < dwLatency){
                   lpThreadState->dwMaxLatency = dwLatency;
               }

               DEBUG_MSG("%lu %s %3d completed: offset=%Lu size=%lu %lu "
                         "latency=%lu\n", lpOIO->dwStartTime,
                         (lpOIO->op == OP_RD ? "Read" : "Write"),
                         i, lpOIO->qwOffset, lpOIO->dwSize, dwLatency);

               /*
                * Calculate the checksum on data (if needed)
                */
               if (opt.bDataChecksum == TRUE && lpOIO->op == OP_RD) {
                  for (j = 0; lpOIO->aSegArray[j].Buffer != NULL; j++) {
                     dwChecksum = computePseudoChecksum(
                                        (char *)lpOIO->aSegArray[j].Buffer,
                                        MEM_PAGE_SIZE);
                  }
               }

               free(outIO[i].aSegArray);
               outIO[i].aSegArray = NULL;
               break;
            }
         }  // for (i = 0; i < dwOutstandingIOs; i++)

         if (i >= dwOutstandingIOs) {
            fprintf(stderr, "ERROR: descriptor not found for IO #%lu\n",
                    lpThreadState->dwCompletedIOs);
            exit(-1);
         }

         memset(&outIO[i], 0, sizeof(OUTSTANDING_IO));
         dwCurrOutstandingIOs--;

      }  // while (dwCurrOutstandingIOs > 0)

      /*
       * Wait for the inter-burst interval before
       * generating another burst.
       */
      if (!opt.bTrace) {
         iIOGap = getIOGap() - (dwBurstFinishTime - dwBurstStartTime);
         if (iIOGap > 0) {
            uSleep(iIOGap);
         }
      }

   }  // Main loop

   DEBUG_MSG("Thread #%lu: Done!\n", lpThreadState->dwThreadID);

   /* Signal main thread that worker is done */
   SetEvent(lpThreadState->phWorkerToMainEvents[lpThreadState->dwThreadID]);

   return 0;
}
#endif

// THREAD_STATE *sharedlpThreadState;
THREAD_STATE *lpThreadState; 
int fd;


#define MAX_OUT 100
OUTSTANDING_IO x_outIO[MAX_OUT];
iocbPtr_t x_iocbList[MAX_OUT];
io_context_t x_ctx_id;
struct io_event *x_events;

static void *
send_io()
{
   

   OUTSTANDING_IO outIO[MAX_OUT];
   iocbPtr_t iocbList[MAX_OUT];
   char lpFileName[STR_SIZE];
   int lastCharIdx;
   // int fd;
   int i;
   io_context_t ctx_id = x_ctx_id;
#ifdef __LINUX__
   struct io_event *events = x_events;
#endif

   reader_t * reader=lpThreadState->reader;
   cache_t *cache= lpThreadState->cache;

   DEBUG_MSG("Thread #%lu: initializing...\n", lpThreadState->dwThreadID);

   memset(outIO, 0, MAX_OUT * sizeof(OUTSTANDING_IO));

   /*
    * Initialize AIO subsystem
    */
   for (i = 0; i < MAX_OUT; i++) {
      iocbList[i] = &outIO[i].iocb;
   }
#ifdef __LINUX__
   
#endif



   /*
    * Open device or test file
    */
   strcpy(lpFileName,opt.lpDevFilePath);
   lastCharIdx = strlen(lpFileName) - 1;
   lpFileName[lastCharIdx] += lpThreadState->dwThreadID;
   if (!opt.bRawDev) {
      //sprintf(lpFileName, "%s/%s", lpFileName, FILE_NAME);
      char tempBuffer[1024]; // or use dynamic allocation if necessary
      snprintf(tempBuffer, sizeof(tempBuffer), "%s/%s", lpFileName, FILE_NAME);
      strcpy(lpFileName, tempBuffer);

   }
   
#ifdef __LINUX__
   
#endif
#ifdef __OSX__
   fd = open(lpFileName, O_RDWR | O_CREAT, 00666);
#endif
   if (fd == -1) {
      fprintf(stderr, "\nERROR: Cannot open '%s' file. Last error = %d (%s)\n",
              lpFileName, errno, strerror(errno));
      exit(-1);
   }
#ifdef __OSX__
   if (!opt.bBufferedIO){
      fcntl(fd, F_NOCACHE, 1);
   } else {
      fcntl(fd, F_NOCACHE, 0);
   }
#endif

   /*
    * Fill the database file
    */
   if (opt.bFillFile) {
      for (i = 0; i < opt.qwFileSize / MAX_WR_SIZE + 1; i++) {
         // printf("writing the file %s \n", threadInfo.pszBuf);
         // exit;
         if (write(fd, threadInfo.pszBuf, MAX_WR_SIZE) == -1) {
            printf("\nERROR: Cannot create '%s' file.  Last error = %d (%s)\n",
                   lpFileName, errno, strerror(errno));
            exit(-1);
         }
      }
   }
   

   /*
    * Synch up with main and other workers
    */
   pthread_mutex_lock(lpThreadState->pMutex);
   (*(lpThreadState->pSynchedThreads))++;
   if (*(lpThreadState->pSynchedThreads) == opt.dwNumThreads) {
      DEBUG_MSG("All threads initialized, signaling...\n");
      pthread_cond_broadcast(lpThreadState->pCond);
   }
   while (*(lpThreadState->pSynchedThreads)  < opt.dwNumThreads){
      pthread_cond_wait(lpThreadState->pCond,
                        lpThreadState->pMutex);
   }
   pthread_mutex_unlock(lpThreadState->pMutex);

   DEBUG_MSG("Thread #%lu: starting IOs on '%s'\n",
             lpThreadState->dwThreadID, lpFileName);

   /*
    * Main test loop
    */
   //  while (!*(lpThreadState->pTestFinished)) {
      DWORD dwOutstandingIOs;
      DWORD dwCurrOutstandingIOs;
      DWORD dwBurstStartTime, dwBurstFinishTime;
      SYSTEMTIME sNow;
      // DWORD dwChecksum;
      DWORD dwChecksum __attribute__((unused));

      int iIOGap;
      OUTSTANDING_IO *lpOIO;
      unsigned res;
      /*
       * IO Issue loop
       */
      // dwOutstandingIOs = getOutstandingIOs();
      dwOutstandingIOs = MAX_OUT;
      dwCurrOutstandingIOs = 0;
      // printf("### MULAI %d \n", dwOutstandingIOs);
      while (dwCurrOutstandingIOs < dwOutstandingIOs) {
         char *memOffset;
         DWORD dwLatency;

         /*
          * Prepare a new I/O
          */
         lpOIO = &outIO[dwCurrOutstandingIOs];
         if (!getNextIOx(lpOIO, lpThreadState->qwLastOffset, reader)) {
            *(lpThreadState->pTestFinished) = TRUE;
            break;
         }
         //printf("dwsize %d\n", lpOIO->dwSize);
         lpThreadState->qwLastOffset = lpOIO->qwOffset;

         memOffset = threadInfo.pszBuf + getRndBufPageAddr();
         if (memOffset + lpOIO->dwSize > threadInfo.pszBuf + opt.dwBufferSize) {
            memOffset -= ROUNDDOWN((memOffset + lpOIO->dwSize) - 
                                   (threadInfo.pszBuf + opt.dwBufferSize),
                                   MEM_PAGE_SIZE);
         }
            

            io_prep_pread(iocbList[dwCurrOutstandingIOs], fd, memOffset,
                          lpOIO->dwSize, lpOIO->qwOffset);


            /*
            * Issue the IO operation
            */
            gettimeofday(&sNow, NULL);
            lpOIO->dwStartTime = convSysTimeToMicrosec(&sNow);
            lpOIO->in_cache = false;
            if (dwCurrOutstandingIOs == 0) {
               dwBurstStartTime = lpOIO->dwStartTime;
            } 

            DEBUG_MSG("%lu %s %3lu issuing  : offset=%Lu size=%lu\n",
                     lpOIO->dwStartTime,
                     (lpOIO->op == OP_RD ? "Read" : "Write"),
                     dwCurrOutstandingIOs, lpOIO->qwOffset, lpOIO->dwSize);

            res = io_submit(ctx_id, 1, &iocbList[dwCurrOutstandingIOs]);
            if (res < 0){
               fprintf(stderr, "Last IO operation failed: "
                              "Error=%u (%s)\n",
               errno, strerror(errno));
               exit(-1);
            }
            dwCurrOutstandingIOs++;

         

         

      }  // while (dwCurrOutstandingIOs < dwOutstandingIOs) 

     
      /*
       * IO completion loop
       */
      while (dwCurrOutstandingIOs > 0) {
         DWORD dwLatency;
         int completed;
         
#ifdef __LINUX__
         do {
            
            completed = io_getevents(ctx_id, 1, 1, events, NULL);
         } while (completed == 0 && errno == 0);
         
#endif
#ifdef __OSX__
         do {
            completed = aio_suspend((const iocb_t* const*)iocbList,
                                     dwOutstandingIOs, NULL);
         } while (errno == EINTR);
#endif
         if (completed < 0) {
            
            fprintf(stderr, "Could not complete IO.  Last error = %d (%s)\n",
                    errno, strerror(errno));
            exit(-1);
         }
         
         /* Look for the completed IO in the outstanding IO list */
         for (i = 0; i < dwOutstandingIOs; i++) {
            lpOIO = &outIO[i];

            
               if (&lpOIO->iocb == (iocbPtr_t)events[0].obj) {

                  /*
                  * IO completed successfully: update counters, compute
                  * latency and warn if it exceeds the alarm threshold
                  */
                  // printf("timestamp %d \n", lpOIO->req->obj_id); 

                  gettimeofday(&sNow, NULL);
                  lpThreadState->dwCompletedIOs++;
                  lpThreadState->qwTotalBytesTransferred += lpOIO->dwSize;
                  dwLatency = convSysTimeToMicrosec(&sNow) - lpOIO->dwStartTime;
                  lpThreadState->dAvgLatency += dwLatency;
                  if (dwCurrOutstandingIOs == 1) {
                     dwBurstFinishTime = convSysTimeToMicrosec(&sNow);
                  }
                  if (dwLatency / 1000 > opt.dwLatencyThreshold){
                     lpThreadState->dwIosAboveLatThresh++;
                     fprintf(stderr, "WARNING: IO #%lu took longer than %lu ms to "
                           "complete (%lu ms)\n", lpThreadState->dwCompletedIOs,
                              opt.dwLatencyThreshold, dwLatency / 1000);
                  }
                  if (lpThreadState->dwMaxLatency < dwLatency){
                     lpThreadState->dwMaxLatency = dwLatency;
                  }

                  
                  DEBUG_MSG("%lu %s %3d completed: offset=%Lu size=%lu "
                           "latency=%lu\n", lpOIO->dwStartTime,
                           (lpOIO->op == OP_RD ? "Read" : "Write"),
                           i, lpOIO->qwOffset, lpOIO->dwSize, dwLatency);

                  /*
                  * Calculate the data checksum on reads completion (if needed)
                  */
                  if (opt.bDataChecksum == TRUE && lpOIO->op == OP_RD) {
                     dwChecksum = computePseudoChecksum(threadInfo.pszBuf,
                                                      lpOIO->dwSize);
                  }

                  break;
               }

            


         }  

         if (i >= dwOutstandingIOs) {
            fprintf(stderr, "ERROR: descriptor not found for IO #%lu\n",
                    lpThreadState->dwCompletedIOs);
            exit(-1);
         }

         memset(lpOIO, 0, sizeof(OUTSTANDING_IO));
         dwCurrOutstandingIOs--;
         
      }  // while (dwCurrOutstandingIOs > 0)
       
      /*
       * Wait for the inter-burst interval before
       * generating another burst.
       */
      if (!opt.bTrace) {
         iIOGap = getIOGap() - (dwBurstFinishTime - dwBurstStartTime);
         if (iIOGap > 0) {
            uSleep(iIOGap);
         }
      }

   // }  // Main loop

   DEBUG_MSG("Thread #%lu: Done!\n", lpThreadState->dwThreadID);

   /* Synch up with main and other workers */
   pthread_mutex_lock(lpThreadState->pMutex);
   (*(lpThreadState->pSynchedThreads))++;
   if (*(lpThreadState->pSynchedThreads) == opt.dwNumThreads) {
      DEBUG_MSG("All threads finished, signaling...\n");
      pthread_cond_broadcast(lpThreadState->pCond);
   }
   pthread_mutex_unlock(lpThreadState->pMutex);

   return NULL;
}

#ifdef __UNIX__
static void *
workerThread(void *lpParam)
{
    if (mkdir(FILE_PATH, 0755) == -1) {
        if (errno != EEXIST) {
            perror("mkdir failed");
        }
    }

   lpThreadState = (THREAD_STATE *) lpParam;
   

   OUTSTANDING_IO outIO[MAX_OUTSTANDING_IOS];
   iocbPtr_t iocbList[MAX_OUTSTANDING_IOS];
   char lpFileName[STR_SIZE];
   int lastCharIdx;
   // int fd;
   int i;
   io_context_t ctx_id;
#ifdef __LINUX__
   struct io_event *events;
#endif

   reader_t * reader=lpThreadState->reader;
   cache_t *cache= lpThreadState->cache;

   char filepath[256];
   snprintf(filepath, sizeof(filepath), "/dev/shm/percentage_log%d.txt", cache->log);
   char filepath2[256];
   snprintf(filepath2, sizeof(filepath2), "/dev/shm/prefetched%d.txt", cache->log);
   char filepath3[256];
   snprintf(filepath3, sizeof(filepath3), "/dev/shm/fetched%d.txt", cache->log);

   // Remove the file if it exists
   remove(filepath);
   remove(filepath2); 
   remove(filepath3); 

   // Now create the file
   FILE *fp = fopen(filepath, "w");
   if (fp == NULL) {
      perror("Failed to open file");
      // Handle error appropriately (exit or return)
   }

   // Now create the file
   FILE *fp2 = fopen(filepath2, "w");
   if (fp2 == NULL) {
      perror("Failed to open file");
      // Handle error appropriately (exit or return)
   }

   // Now create the file
   FILE *fp3 = fopen(filepath3, "w");
   if (fp3 == NULL) {
      perror("Failed to open file 3");
      // Handle error appropriately (exit or return)
   }

   DEBUG_MSG("Thread #%lu: initializing...\n", lpThreadState->dwThreadID);

   memset(outIO, 0, MAX_OUTSTANDING_IOS * sizeof(OUTSTANDING_IO));

   /*
    * Initialize AIO subsystem
    */
   for (i = 0; i < MAX_OUTSTANDING_IOS; i++) {
      iocbList[i] = &outIO[i].iocb;
   }
#ifdef __LINUX__
   memset(&ctx_id, 0, sizeof(io_context_t));
   if (io_queue_init(MAX_OUTSTANDING_IOS, &ctx_id) < 0) {
      fprintf(stderr, "\nERROR: Cannot initialize completion queue."
              "  Last error = %d (%s)\n", errno, strerror(errno));
      exit(-1);
   }

   events = calloc(MAX_OUTSTANDING_IOS, sizeof(struct io_event));
   if (events == NULL) {
      fprintf(stderr, "\nERROR: Could not allocate memory for event array\n");
      exit(-1);
   }
#endif

//coba sendiri
   memset(&x_ctx_id, 0, sizeof(io_context_t));
   if (io_queue_init(MAX_OUT, &x_ctx_id) < 0) {
      fprintf(stderr, "\nERROR: xxCannot initialize completion queue."
              "  Last error = %d (%s)\n", errno, strerror(errno));
      exit(-1);
   }

   x_events = calloc(MAX_OUT, sizeof(struct io_event));
   if (x_events == NULL) {
      fprintf(stderr, "\nERROR: xxCould not allocate memory for event array\n");
      exit(-1);
   }
//coba sendiri

   /*
    * Open device or test file
    */
   strcpy(lpFileName,opt.lpDevFilePath);
   lastCharIdx = strlen(lpFileName) - 1;
   lpFileName[lastCharIdx] += lpThreadState->dwThreadID;
   if (!opt.bRawDev) {
      //sprintf(lpFileName, "%s/%s", lpFileName, FILE_NAME);
      char tempBuffer[1024]; // or use dynamic allocation if necessary
      snprintf(tempBuffer, sizeof(tempBuffer), "%s/%s", lpFileName, FILE_NAME);
      strcpy(lpFileName, tempBuffer);

   }
   
#ifdef __LINUX__
   // if (fd == -1) {
      if (opt.bBufferedIO) {
         fd = open(lpFileName, O_RDWR | O_CREAT | O_LARGEFILE, 00666);
      } else {
         fd = open(lpFileName, O_RDWR | O_CREAT | O_LARGEFILE | O_DIRECT, 00666);
      }
   // }
#endif
#ifdef __OSX__
   fd = open(lpFileName, O_RDWR | O_CREAT, 00666);
#endif
   if (fd == -1) {
      fprintf(stderr, "\nERROR: Cannot open '%s' file. Last error = %d (%s)\n",
              lpFileName, errno, strerror(errno));
      exit(-1);
   }
#ifdef __OSX__
   if (!opt.bBufferedIO){
      fcntl(fd, F_NOCACHE, 1);
   } else {
      fcntl(fd, F_NOCACHE, 0);
   }
#endif

   /*
    * Fill the database file
    */
   if (opt.bFillFile) {
      for (i = 0; i < opt.qwFileSize / MAX_WR_SIZE + 1; i++) {
         // printf("writing the file %s \n", threadInfo.pszBuf);
         // exit;
         if (write(fd, threadInfo.pszBuf, MAX_WR_SIZE) == -1) {
            printf("\nERROR: Cannot create '%s' file.  Last error = %d (%s)\n",
                   lpFileName, errno, strerror(errno));
            exit(-1);
         }
      }
   }
   

   uint64_t total_req=0;
   uint64_t total_miss=0;

   /*
    * Synch up with main and other workers
    */
   pthread_mutex_lock(lpThreadState->pMutex);
   (*(lpThreadState->pSynchedThreads))++;
   if (*(lpThreadState->pSynchedThreads) == opt.dwNumThreads) {
      DEBUG_MSG("All threads initialized, signaling...\n");
      pthread_cond_broadcast(lpThreadState->pCond);
   }
   while (*(lpThreadState->pSynchedThreads)  < opt.dwNumThreads){
      pthread_cond_wait(lpThreadState->pCond,
                        lpThreadState->pMutex);
   }
   pthread_mutex_unlock(lpThreadState->pMutex);

   DEBUG_MSG("Thread #%lu: starting IOs on '%s'\n",
             lpThreadState->dwThreadID, lpFileName);

   /*
    * Main test loop
    */
    while (!*(lpThreadState->pTestFinished)) {
      DWORD dwOutstandingIOs;
      DWORD dwCurrOutstandingIOs;
      DWORD dwBurstStartTime, dwBurstFinishTime;
      SYSTEMTIME sNow;
      // DWORD dwChecksum;
      DWORD dwChecksum __attribute__((unused));

      int iIOGap;
      OUTSTANDING_IO *lpOIO;
      unsigned res;
      
      /*
       * IO Issue loop
       */
      dwOutstandingIOs = getOutstandingIOs();
      dwCurrOutstandingIOs = 0;
      
      while (dwCurrOutstandingIOs < dwOutstandingIOs) {
         char *memOffset;
         DWORD dwLatency;

         /*
          * Prepare a new I/O
          */
         lpOIO = &outIO[dwCurrOutstandingIOs];
         if (!getNextIO(lpOIO, lpThreadState->qwLastOffset, reader)) {
            *(lpThreadState->pTestFinished) = TRUE;
            break;
         }
         lpThreadState->qwLastOffset = lpOIO->qwOffset;

         memOffset = threadInfo.pszBuf + getRndBufPageAddr();
         if (memOffset + lpOIO->dwSize > threadInfo.pszBuf + opt.dwBufferSize) {
            memOffset -= ROUNDDOWN((memOffset + lpOIO->dwSize) - 
                                   (threadInfo.pszBuf + opt.dwBufferSize),
                                   MEM_PAGE_SIZE);
         }

         bool cont;
         // if nocache = yes, always miss
         if(cache->nocache){
            cont = cache->nocache;
         // if nocache = no, check cache
         }else{
            cont = cache->get(cache, lpOIO->req) == false;
         } 
         if(cont){ 
            total_miss++;
            
            io_prep_pread(iocbList[dwCurrOutstandingIOs], fd, memOffset,
                          lpOIO->dwSize, lpOIO->qwOffset);
            /*
            * Issue the IO operation
            */
            gettimeofday(&sNow, NULL);
            lpOIO->dwStartTime = convSysTimeToMicrosec(&sNow);
            lpOIO->in_cache = false;
            if (dwCurrOutstandingIOs == 0) {
               dwBurstStartTime = lpOIO->dwStartTime;
            } 

            DEBUG_MSG("%lu %s %3lu issuing  : offset=%Lu size=%lu\n",
                     lpOIO->dwStartTime,
                     (lpOIO->op == OP_RD ? "Read" : "Write"),
                     dwCurrOutstandingIOs, lpOIO->qwOffset, lpOIO->dwSize);

            res = io_submit(ctx_id, 1, &iocbList[dwCurrOutstandingIOs]);
            if (res < 0){
               fprintf(stderr, "Last IO operation failed: "
                              "Error=%u (%s)\n",
               errno, strerror(errno));
               exit(-1);
            }
            dwCurrOutstandingIOs++;
                      
         }else{ 
            
            gettimeofday(&sNow, NULL);
            lpOIO->dwStartTime = convSysTimeToMicrosec(&sNow);
            lpOIO->in_cache = true;
            if (dwCurrOutstandingIOs == 0) {
               dwBurstStartTime = lpOIO->dwStartTime;
            } 

            DEBUG_MSG("%lu %s %3lu issuing  : offset=%Lu size=%lu\n",
                     lpOIO->dwStartTime,
                     (lpOIO->op == OP_RD ? "Read" : "Write"),
                     dwCurrOutstandingIOs, lpOIO->qwOffset, lpOIO->dwSize);
            
            gettimeofday(&sNow, NULL);
            lpThreadState->dwCompletedIOs++;
            lpThreadState->qwTotalBytesTransferred += lpOIO->dwSize;
            dwLatency = convSysTimeToMicrosec(&sNow) - lpOIO->dwStartTime;
            lpThreadState->dAvgLatency += dwLatency;
            if (dwCurrOutstandingIOs == 1) {
               dwBurstFinishTime = convSysTimeToMicrosec(&sNow);
            }
            if (dwLatency / 1000 > opt.dwLatencyThreshold){
               lpThreadState->dwIosAboveLatThresh++;
               fprintf(stderr, "WARNING: IO #%lu took longer than %lu ms to "
                     "complete (%lu ms)\n", lpThreadState->dwCompletedIOs,
                        opt.dwLatencyThreshold, dwLatency / 1000);
            }
            if (lpThreadState->dwMaxLatency < dwLatency){
               lpThreadState->dwMaxLatency = dwLatency;
            }

         }
         total_req++;
   
         // if (fp != NULL) {
         //       fprintf(fp, "%.4lf\n", (double)total_miss/ total_req);
         //       fflush(fp);
         // }
         // if (fp3 != NULL) {
         //       fprintf(fp3, "%d,%d\n", total_req,total_miss);
         //       fflush(fp3);
         // }
         

      }  // while (dwCurrOutstandingIOs < dwOutstandingIOs) 

      
      /*
       * IO completion loop
       */
      while (dwCurrOutstandingIOs > 0) {
         DWORD dwLatency;
         int completed;
         
#ifdef __LINUX__
         do {
            
            completed = io_getevents(ctx_id, 1, 1, events, NULL);
         } while (completed == 0 && errno == 0);
#endif
#ifdef __OSX__
         do {
            completed = aio_suspend((const iocb_t* const*)iocbList,
                                     dwOutstandingIOs, NULL);
         } while (errno == EINTR);
#endif
         if (completed < 0) {
            
            fprintf(stderr, "Could not complete IO.  Last error = %d (%s)\n",
                    errno, strerror(errno));
            exit(-1);
         }
         /* Look for the completed IO in the outstanding IO list */
         for (i = 0; i < dwOutstandingIOs; i++) {
            lpOIO = &outIO[i];

            
               if (&lpOIO->iocb == (iocbPtr_t)events[0].obj) {

                  /*
                  * IO completed successfully: update counters, compute
                  * latency and warn if it exceeds the alarm threshold
                  */
                  

                  gettimeofday(&sNow, NULL);
                  lpThreadState->dwCompletedIOs++;
                  lpThreadState->qwTotalBytesTransferred += lpOIO->dwSize;
                  dwLatency = convSysTimeToMicrosec(&sNow) - lpOIO->dwStartTime;
                  lpThreadState->dAvgLatency += dwLatency;
                  if (dwCurrOutstandingIOs == 1) {
                     dwBurstFinishTime = convSysTimeToMicrosec(&sNow);
                  }
                  if (dwLatency / 1000 > opt.dwLatencyThreshold){
                     lpThreadState->dwIosAboveLatThresh++;
                     fprintf(stderr, "WARNING: IO #%lu took longer than %lu ms to "
                           "complete (%lu ms)\n", lpThreadState->dwCompletedIOs,
                              opt.dwLatencyThreshold, dwLatency / 1000);
                  }
                  if (lpThreadState->dwMaxLatency < dwLatency){
                     lpThreadState->dwMaxLatency = dwLatency;
                  }

                  
                  DEBUG_MSG("%lu %s %3d completed: offset=%Lu size=%lu "
                           "latency=%lu\n", lpOIO->dwStartTime,
                           (lpOIO->op == OP_RD ? "Read" : "Write"),
                           i, lpOIO->qwOffset, lpOIO->dwSize, dwLatency);

                  /*
                  * Calculate the data checksum on reads completion (if needed)
                  */
                  if (opt.bDataChecksum == TRUE && lpOIO->op == OP_RD) {
                     dwChecksum = computePseudoChecksum(threadInfo.pszBuf,
                                                      lpOIO->dwSize);
                  }

                  break;
               }

            // }


         }  // for (i = 0; i < dwOutstandingIOs; i++)

         if (i >= dwOutstandingIOs) {
            fprintf(stderr, "ERROR: descriptor not found for IO #%lu\n",
                    lpThreadState->dwCompletedIOs);
            exit(-1);
         }

         memset(lpOIO, 0, sizeof(OUTSTANDING_IO));
         dwCurrOutstandingIOs--;
         
      }  // while (dwCurrOutstandingIOs > 0)
       
      /*
       * Wait for the inter-burst interval before
       * generating another burst.
       */
      if (!opt.bTrace) {
         iIOGap = getIOGap() - (dwBurstFinishTime - dwBurstStartTime);
         if (iIOGap > 0) {
            uSleep(iIOGap);
         }
      }

   }  // Main loop

   DEBUG_MSG("Thread #%lu: Done!\n", lpThreadState->dwThreadID);

   /* Synch up with main and other workers */
   pthread_mutex_lock(lpThreadState->pMutex);
   (*(lpThreadState->pSynchedThreads))++;
   if (*(lpThreadState->pSynchedThreads) == opt.dwNumThreads) {
      DEBUG_MSG("All threads finished, signaling...\n");
      pthread_cond_broadcast(lpThreadState->pCond);
   }
   pthread_mutex_unlock(lpThreadState->pMutex);

   return NULL;
}
#endif // #ifdef __UNIX__


/*-----------------------------------------------------------------------------
 *
 * createWorkerThreads --
 *
 *     Create the worker threads.
 *
 * Results:
 *      None
 *
 * Side effects:
 *      Worker threads are created.
 *
 *-----------------------------------------------------------------------------
 */
static void
// createWorkerThreads(void) {
createWorkerThreads(reader_t *reader, cache_t *cache) {
   unsigned i;

   threadInfo.bTestFinished = FALSE;
   threadInfo.sThreads = calloc(opt.dwNumThreads, sizeof(THREAD_STATE));
   if (threadInfo.sThreads == NULL) {
      fprintf(stderr,
              "ERROR: could not allocate memory for thread state array\n");
      exit(-1);
   }

#ifdef _WIN32
   /*
    * Create the event arrays used to sync main and worker threads
    */
   threadInfo.hMainToWorkerEvents = (HANDLE *)calloc(opt.dwNumThreads,
                                                     sizeof(HANDLE));
   threadInfo.hWorkerToMainEvents = (HANDLE *)calloc(opt.dwNumThreads,
                                                     sizeof(HANDLE));
   if (threadInfo.hMainToWorkerEvents == NULL ||
       threadInfo.hWorkerToMainEvents == NULL) {
      fprintf(stderr,
              "ERROR: could not allocate memory for event handles\n");
      exit(-1);
   }
   for (i = 0; i < opt.dwNumThreads; i++ ) {
      threadInfo.hMainToWorkerEvents[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
      threadInfo.hWorkerToMainEvents[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
      threadInfo.sThreads[i].phWorkerToMainEvents = threadInfo.hWorkerToMainEvents;
      threadInfo.sThreads[i].phMainToWorkerEvents = threadInfo.hMainToWorkerEvents;
      threadInfo.sThreads[i].pTestFinished = &threadInfo.bTestFinished;
      threadInfo.sThreads[i].dwThreadID = i;
      threadInfo.sThreads[i].hThread = (HANDLE)_beginthreadex(NULL,
                                                       0,
                                                       workerThread,
                                                       &threadInfo.sThreads[i],
                                                       0,
                                                       NULL);
      if (threadInfo.sThreads[i].hThread == 0) {
         fprintf(stderr, "ERROR: could not start thread #%d\n", i);
         exit(-1);
      }
   }
#endif
#ifdef __UNIX__
   pthread_mutex_init(&threadInfo.mutex, NULL);
   pthread_cond_init(&threadInfo.cond, NULL);
   threadInfo.synchedThreads = 0;
   for (i = 0; i < opt.dwNumThreads; i++ ) {
      threadInfo.sThreads[i].dwThreadID = i;
      threadInfo.sThreads[i].pCond = &threadInfo.cond;
      threadInfo.sThreads[i].pMutex = &threadInfo.mutex;
      threadInfo.sThreads[i].pSynchedThreads = &threadInfo.synchedThreads;
      threadInfo.sThreads[i].pTestFinished = &threadInfo.bTestFinished;
      threadInfo.sThreads[i].reader = reader;
      threadInfo.sThreads[i].cache = cache;
      if (pthread_create(&threadInfo.sThreads[i].hThread,
          NULL,
          workerThread,
          &threadInfo.sThreads[i]) != 0) {
         fprintf(stderr, "ERROR: could not start thread #%d\n", i);
         exit(-1);
      }
   }
#endif
}

/*-----------------------------------------------------------------------------
 *
 * synchWorkerThreads --
 *
 *     Syncronize all the worker threads with the main thread.
 *
 * Results:
 *      None
 *
 * Side effects:
 *      Worker threads stop until signalled by the main thread.
 *
 *-----------------------------------------------------------------------------
 */
static void
synchWorkerThreads(void) {
#ifdef _WIN32
   unsigned i;

   WaitForMultipleObjects(opt.dwNumThreads,
                          threadInfo.hWorkerToMainEvents,
                          TRUE,
                          INFINITE);

   for (i = 0; i < opt.dwNumThreads; i++) {
      SetEvent(threadInfo.hMainToWorkerEvents[i]);
   }
#endif
#ifdef __UNIX__
   pthread_mutex_lock(&threadInfo.mutex);
   while (threadInfo.synchedThreads < opt.dwNumThreads){
      fprintf(stderr, "threadInfo.synchedThreads %d   \n", threadInfo.synchedThreads);
      // fprintf(stderr, "opt.dwNumThreads %d   \n", opt.dwNumThreads);
      fprintf(stderr, "opt.dwNumThreads %lu   \n", opt.dwNumThreads);
      pthread_cond_wait(&threadInfo.cond, &threadInfo.mutex);
   }
   pthread_mutex_unlock(&threadInfo.mutex);
#endif
}


/*-----------------------------------------------------------------------------
 *
 * CtrlCHandler --
 *
 *     Handler for the SIGINT signal (CTRL-C)
 *
 * Results:
 *      None
 *
 * Side effects:
 *      Causes IOblazer to terminate gracefully (i.e., print out the
 *      partial results) when the user presse CTRL-C
 *
 *-----------------------------------------------------------------------------
 */
static void
CtrlCHandler(int signal)
{
   threadInfo.bTestFinished = TRUE;
}

